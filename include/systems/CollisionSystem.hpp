#ifndef COLLISIONSYSTEM_HPP
#define COLLISIONSYSTEM_HPP

#include <vector>
#include <cstddef>
#include <functional>
#include <vector.hpp>

// Forward declarations
class Scene;
struct Body;
struct CircleBody;
class SupportFunction;


class CollisionSystem {
public:
	CollisionSystem(Scene& scene);
	void update();

private:
	typedef std::function<Vector2f(const Vector2f&)> SupportFunction;

	static constexpr float eps{0.0001f};
	Scene& _scene;

	// List of 2D points formed by the difference of two shapes. This class
	// makes it easy to store and pass around the difference and the original
	// points together.
	class MinkowskyPolygon {
	public:
		void pushBack(const Vector2f& A, const Vector2f& B);
		void insert(std::size_t index, const Vector2f& A, const Vector2f& B);
		void erase(std::size_t index);
		Vector2f getDifference(std::size_t index) const;
		Vector2f getPointA(std::size_t index) const;
		Vector2f getPointB(std::size_t index) const;
		std::size_t size() const;

	private:
		std::vector<Vector2f> _pointsA, _pointsB;
	};

	// Information about the contact points or the distance between two bodies.
	// It is used by the contact point function two describe the collision
	// between two bodies, and by the distance function to describe the gap
	// between two bodies.
	struct ContactInfo {
		// Point on A and B in world coordinates where body A and body B would
		// touch if they were brought close enough to touch but not overlap.
		// They belong to the border of the bodies, and are the furthest point
		// into the collision.
		Vector2f C_A, C_B;
		// Collision normal vector, pointing from A to B. If A is shifted by
		// this vector times the signed distance, the bodies will just touch but
		// not overlap or be separated anymore.
		Vector2f normal;
		// Signed distance between C_A and C_B. Positive means no overlap,
		// negative means overlap
		float distance;
	};

	void collideConvexes(const SupportFunction& functionA, const SupportFunction& functionB, Body& bodyA, Body& bodyB);

	// In the special case of two circle, the collision detection and response
	// is much simpler, so we do both at once here.
	void collideCircles(const CircleBody& circleA, const CircleBody& circleB, Body& bodyA, Body& bodyB);

	void collideCircleAndConvex(const CircleBody& circleA, const SupportFunction& functionB, Body& bodyA, Body& bodyB);

	// Collision response between arbitrary bodies.
	void collisionResponse(Body& bodyA, Body& bodyB, const ContactInfo& contactInfo);

	// The Gilbert–Johnson–Keerthi (GJK) algorithm detects collisions between
	// two bodies, and returns the simplex in the Minkowsky difference that is
	// closed to the origin (enclosing it if there is a collision), along with a
	// boolean indicating if there is collision.
	std::pair<bool, MinkowskyPolygon> collisionGJK(const SupportFunction& functionA, const SupportFunction& functionB);

	// The GJK algorithm adapted to find the distance between two noncolliding
	// convex bodies. It starts off with the simplex generated by collision GJK.
	ContactInfo distanceGJK(const SupportFunction& functionA, const SupportFunction& functionB, MinkowskyPolygon polygon);

	// The Expanding Polytope Algorithm computes the collision vector, which is
	// the minimum vector that would stop the shapes from overlapping. It takes
	// as input the simplex enclosing the origin computed by collision GJK.
	ContactInfo EPA(const SupportFunction& functionA, const SupportFunction& functionB, MinkowskyPolygon polygon);

	ContactInfo createContactInfo(const MinkowskyPolygon& simplex, std::size_t i, std::size_t j, bool inside);

	// Updates the simplex for collision GJK. It just dispatches to the line or
	// triangle functions. The simplex and the direction vector are both updated
	// in-place. Returns true if the origin is in the simplex
	bool updateSimplex(MinkowskyPolygon& simplex, Vector2f& direction);

	// Computes the new direction as the vector orthogonal to the simplex
	// towards the origin. Returns false.
	bool updateSimplexLine(MinkowskyPolygon& simplex, Vector2f& direction);

	// Checks if the origin is enclosed in the simplex. If not, finds the
	// closest edge to the origin and set the direction towards the origin
	// orthogonal from this edge.
	bool updateSimplexTriangle(MinkowskyPolygon& simplex, Vector2f& direction);

	// Returns the closest point to the origin on the simplex, and removes the
	// simplex vertex that is not part of the simplex feature closest to the
	// origin. To use only when simplex.size() == 3.
	Vector2f updateSimplexDistance(MinkowskyPolygon& simplex);

};

#endif // COLLISIONSYSTEM_HPP
